package com.rdebokx.ltga.experiments.optimalFixedFOS;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;

import com.rdebokx.ltga.config.ExecutionConfiguration;
import com.rdebokx.ltga.config.GeneticConfiguration;
import com.rdebokx.ltga.config.JobConfiguration;
import com.rdebokx.ltga.config.problems.OptimalFixedFOSConfiguration;
import com.rdebokx.ltga.parallel.ParallelJobRunner;
import com.rdebokx.ltga.shared.LearningModel;
import com.rdebokx.ltga.shared.ParameterSet;
import com.rdebokx.ltga.shared.Problem;
import com.rdebokx.ltga.shared.ProblemEvaluator;

/**
 * Recombinative Optimal Fixed FOS Determinator
 *
 */
public class ROFFDeterminator {
	
	private static int threads;
	private static int popSize;
	
	/**
	 * This is the main entry point for the Recombinative Optimal Fixed FOS Determinator.
	 * This executable is aimed at overcoming the flaws of the OFFDETERMINATOR, when intermediate sets are not beneficial for a fixed
	 * FOS. This is done by first generatin all interesting FOS elements, after which the LTGA will be executed on this FOS to define
	 * an optimal Fixed FOS. 
	 * @param args problem | params | valueToReach | popSize | threads or problem | params | inputBasis | inputFile | popSize | threads
	 */
	public static void main(String[] args){
		OptimalFixedFOSConfiguration config = parseConfig(args);
		
		ArrayList<ParameterSet> combinations = readCombinations(config.EVALUATION_CONFIG.PROBLEM_CONFIG.PROBLEM, config.EVALUATION_CONFIG.GENETIC_CONFIG.NUMBER_OF_PARAMETERS);
		System.out.println(combinations.size() + " generated Combinations: " + combinations);
		
		//run meta-LTGA on this set of combinations.
		OptimalFixedFOSConfiguration OFFConfig = new OptimalFixedFOSConfiguration(combinations, config.EVALUATION_CONFIG, config.SEEDS);
		ExecutionConfiguration execConfig = new ExecutionConfiguration(threads, -1, -1, false, -1, ExecutionConfiguration.DEFAULT_FITNESS_VARIANCE_TOLERANCE);
        GeneticConfiguration geneticConfig = new GeneticConfiguration(popSize, popSize, popSize, combinations.size());
        JobConfiguration jobConfig = new JobConfiguration(geneticConfig, execConfig, OFFConfig);
        dynamicROFFFinding(jobConfig);
	}
	
	/**
	 * This function reads the combinations that were generated by the ROFFGenerator from file.
	 * @param problem The problem for which the combinations have to be read.
	 * @param numberOfParameters The amount of parameters for the problem for which the combinations have to be read.
	 * @return An ArrayList, containing all the read combinations.
	 */
	private static ArrayList<ParameterSet> readCombinations(Problem problem, int numberOfParameters) {
		ArrayList<ParameterSet> result = new ArrayList<ParameterSet>();
		File f = new File(ROFFGenerator.getFileName(problem, numberOfParameters));
		if(f.exists() && f.isFile()) {
			try {
				
				BufferedReader reader = new BufferedReader(new FileReader(f));
				reader.lines().forEach((line) -> {
					String[] elements = line.replace("]", "").replace("[", "").split(" ");
					ParameterSet newSet = new ParameterSet();
					for(String element: elements){
						newSet.add(Integer.parseInt(element));
					}
					result.add(newSet);
				});
				reader.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return result;
	}

	/**
	 * This method will attempt to find the Optimal Fixed FOS dynamically for the provided configuration.
	 * @param jobConfig The jobConfiguration for which the Optimal Fixed FOS has to be found.
	 */
	private static void dynamicROFFFinding(JobConfiguration jobConfig){
        while(true){
        	System.out.println("Starting with n=" + jobConfig.GENETIC_CONFIG.POPULATION_SIZE + " at " + new Date());
        	ParallelJobRunner runner = new ParallelJobRunner(jobConfig, true);
            runner.run();
    		OFFDeterminator.parseFoundResults(runner.getBestFound(), (OptimalFixedFOSConfiguration) jobConfig.PROBLEM_CONFIG);
        	jobConfig = jobConfig.copyForPopSize(jobConfig.GENETIC_CONFIG.POPULATION_SIZE * 2);
        }
		
	}
	
	/**
	 * This function parses the provided arguments to an OptimalFixedFOSConfiguration object.
	 * @param args problem | params | valueToReach | popSize | threads or problem | params | inputBasis | inputFile | popSize | threads
	 * @return The parsed configuration.
	 */
	public static OptimalFixedFOSConfiguration parseConfig(String[] args){
		//Format: Problem | params | valueToReach | popSize | threads 
        OptimalFixedFOSConfiguration result = null;
        try{
        	Problem problem = Problem.valueOf(args[0]);
        	int params = Integer.parseInt(args[1]);
        	popSize = Integer.parseInt(args[args.length - 2]);
            threads = Integer.parseInt(args[args.length - 1]);
            
            switch(problem){
            case MAXCUT:
                result = OFFDeterminator.constructMaxCutOFFConfig(problem, params, args[2], args[3], OFFDeterminator.SEEDS_FILE);
                break;
            case NK_LANDSCAPES:
                result = OFFDeterminator.constructNKOFFConfig(problem, params, args[2], args[3], OFFDeterminator.SEEDS_FILE);
                break;
            default:
                double valueToReach = Double.parseDouble(args[2]);
                result = OFFDeterminator.constructOFFConfig(problem, params, valueToReach, OFFDeterminator.SEEDS_FILE);
                break;
            }
        } catch(Exception e){
            e.printStackTrace();
            System.out.println("Please provide problem | params | valueToReach | popSize | threads or problem | params | inputBasis | inputFile | popSize | threads");
        }
        System.out.println("Make OFFConfig");
        return makeOFFConfig(result);
    }
	
	/**
     * This function creates a new OptimalFixedFOSConfiguration object based on the given configuration, however the maximum
     * amount of evaluations for the evaluation config is now set to the LTGA score provided.
     * @param config The configuration on which the new OFFConfig has to be based. All values will be copied, except for the maximum amount of evaluations in the evaluation configuration
     * @return The altered OptimalFixedFOSConfiguration.
     */
    public static OptimalFixedFOSConfiguration makeOFFConfig(OptimalFixedFOSConfiguration config){
        LearningModel LTGA = null;
        int LTGAScore = (int) Math.ceil(-1 * ProblemEvaluator.OptimalFixedFOSFunctionProblemEvaluation(config, LTGA));
        //System.out.println("LTGAScore: " + LTGAScore);
        ExecutionConfiguration newExecConfig = new ExecutionConfiguration(
                config.EVALUATION_CONFIG.EXECUTION_CONFIG.THREADS,
                config.EVALUATION_CONFIG.EXECUTION_CONFIG.MAX_NO_IMPROVEMENT_STRETCH,
                LTGAScore,
                config.EVALUATION_CONFIG.EXECUTION_CONFIG.USE_VALUE_TO_REACH,
                config.EVALUATION_CONFIG.EXECUTION_CONFIG.VALUE_TO_REACH,
                config.EVALUATION_CONFIG.EXECUTION_CONFIG.FITNESS_VARIANCE_TOLERANCE);
        JobConfiguration newEvalConfig = new JobConfiguration(config.EVALUATION_CONFIG.GENETIC_CONFIG, newExecConfig, config.EVALUATION_CONFIG.PROBLEM_CONFIG);
        return new OptimalFixedFOSConfiguration(config.LINKAGE_SETS, newEvalConfig, config.SEEDS);
    }
	
}
